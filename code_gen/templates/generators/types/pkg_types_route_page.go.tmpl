/*
output: pkg/types/[[route]]/page.go
scope: type
*/

{{- $class := .Class -}}
{{- $lower := toLower $class -}}
{{- $isDresses := eq $class "Dresses" -}}
// Copyright 2016, 2026 The Authors. All rights reserved.
// Use of this source code is governed by a license that can
// be found in the LICENSE file.
/*
 * Parts of this file were auto generated. Edit only those parts of
 * the code inside of 'EXISTING_CODE' tags.
 */

package {{$lower}}

// EXISTING_CODE
// EXISTING_CODE

type {{.Class}}Page struct {
	Facet         types.DataFacet      `json:"facet"`
	{{range .Stores}}{{.Name}} []{{toSingular .Name}} `json:"{{toLower .Name}}"`
{{end -}}
	TotalItems    int                  `json:"totalItems"`
	ExpectedTotal int                  `json:"expectedTotal"`
	State         types.StoreState      `json:"state"`
	// EXISTING_CODE
	// EXISTING_CODE
}

func (p *{{.Class}}Page) GetFacet() types.DataFacet {
	return p.Facet
}

func (p *{{.Class}}Page) GetTotalItems() int {
	return p.TotalItems
}

func (p *{{.Class}}Page) GetExpectedTotal() int {
	return p.ExpectedTotal
}

func (p *{{.Class}}Page) GetState() types.StoreState {
	return p.State
}

func (c *{{.Class}}Collection) GetPage(
	payload *types.Payload,
	first, pageSize int,
	sortSpec sdk.SortSpec,
	filter string,
) (types.Page, error) {
	filter = strings.ToLower(filter)
	dataFacet := payload.DataFacet
	page := &{{.Class}}Page{
		Facet: dataFacet,
	}
	_ = preprocessPage(c, page, payload, first, pageSize, sortSpec)
	{{- if $isDresses }}
	if page.Facet == DressesGenerator || page.Facet == DressesGallery {
		first = 0
		pageSize = 1_000_000_000
	}
	{{- end}}

	if c.shouldSummarize(payload) {
		return c.getSummaryPage(payload, first, pageSize, sortSpec, filter)
	}

	switch dataFacet {
	{{range .Facets}}
	{{- if not .IsDynamic}}
	{{$sing := toSingular .Name -}}
	case {{$class}}{{.Name}}:
		facet := c.{{toLower .Name}}Facet
		var filterFunc func(*{{toSingular .StoreName}}) bool
		if filter != "" {
			filterFunc = func(item *{{toSingular .StoreName}}) bool {
				return c.matches{{$sing}}Filter(item, filter)
			}
		}
		sortFunc := func(items []{{toSingular .StoreName}}, sort sdk.SortSpec) error {
			return {{.StoreSource}}.Sort{{.StoreName}}(items, sort)
		}
		if result, err := facet.GetPage(first, pageSize, filterFunc, sortSpec, sortFunc); err != nil {
			return nil, types.NewStoreError("{{$lower}}", dataFacet, "GetPage", err)
		} else {
			page.{{.StoreName}} = result.Items
			page.TotalItems = result.TotalItems
			page.State = result.State
		}
		page.ExpectedTotal = facet.ExpectedCount()
	{{- end}}
	{{- end}}
	default:
		{{- if .HasDynamicFacets}}
		id := string(payload.DataFacet)
		c.ensureProjectFacet(payload)
		if projectFacet, exists := c.projectsFacets[id]; exists {
			var filterFunc func(*AddressList) bool
			if filter != "" {
				filterFunc = func(item *AddressList) bool {
					return c.matchesProjectFilter(item, filter)
				}
			}
			sortFunc := func(items []AddressList, sort sdk.SortSpec) error {
				return nil // project.SortAddressList(items, sort)
			}
			if result, err := projectFacet.GetPage(first, pageSize, filterFunc, sortSpec, sortFunc); err != nil {
				return nil, types.NewStoreError("{{$lower}}", payload.DataFacet, "GetPage", err)
			} else {
				page.AddressList = result.Items
				page.TotalItems = result.TotalItems
				page.State = result.State
			}
			page.ExpectedTotal = projectFacet.ExpectedCount()
		} else {
			return nil, types.NewValidationError("{{$lower}}", payload.DataFacet, "GetPage",
				fmt.Errorf("[GetPage] facet not found: %v", payload.DataFacet))
		}
		{{- else}}
		return nil, types.NewValidationError("{{$lower}}", payload.DataFacet, "GetPage",
			fmt.Errorf("[GetPage] unsupported dataFacet: %v", payload.DataFacet))
		{{- end}}
	}

	return page, nil
}

// shouldSummarize returns true if the current facet can be simmarized by period
func (c *{{.Class}}Collection) shouldSummarize(payload *types.Payload) bool {
	if !payload.ShouldSummarize() {
		return false
	}
	// EXISTING_CODE
	// EXISTING_CODE
	return false
}

// getSummaryPage returns paginated summary data for a given period
func (c *{{.Class}}Collection) getSummaryPage(
	payload *types.Payload,
	first, pageSize int,
	sortSpec sdk.SortSpec,
	filter string,
) (types.Page, error) {
	// TODO: Use these
	dataFacet := payload.DataFacet
	period := payload.ActivePeriod
	_ = first
	_ = pageSize
	_ = sortSpec
	_ = filter
	// CRITICAL: Ensure underlying raw data is loaded before generating summaries
	// For summary periods, we need the blockly (raw) data to be loaded first
	c.FetchByFacet(payload)
	if err := c.generateSummariesForPeriod(dataFacet, period); err != nil {
		return nil, types.NewStoreError("exports", dataFacet, "getSummaryPage", err)
	}

	page := &{{.Class}}Page{
		Facet: dataFacet,
	}

	switch dataFacet {
	// EXISTING_CODE
	// EXISTING_CODE
	default:
		return nil, types.NewValidationError("{{$lower}}", dataFacet, "getSummaryPage",
			fmt.Errorf("[getSummaryPage] unsupported dataFacet: %v %v", dataFacet, page.Facet))
	}
}

// generateSummariesForPeriod ensures summaries are generated for the given period
func (c *{{.Class}}Collection) generateSummariesForPeriod(dataFacet types.DataFacet, period types.Period) error {
	// TODO: Use this
	_ = period
	switch dataFacet {
	// EXISTING_CODE
	// EXISTING_CODE
	default:
		return fmt.Errorf("[generateSummariesForPeriod] unsupported dataFacet for summary: %v", dataFacet)
	}
}

func preprocessPage(
	c *{{.Class}}Collection,
	page *{{.Class}}Page,
	payload *types.Payload,
	first, pageSize int,
	sortSpec sdk.SortSpec,
) error {
	_ = page
	_ = c
	_ = payload
	_ = first
	_ = pageSize
	_ = sortSpec
	// EXISTING_CODE
	// EXISTING_CODE
	return nil
}

// EXISTING_CODE
// EXISTING_CODE
