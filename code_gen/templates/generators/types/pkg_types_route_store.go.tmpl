/*
output: pkg/types/[[route]]/store.go
scope: type
*/

{{- $class := .Class -}}
{{- $isNames := eq .Class "Names" -}}
// Copyright 2016, 2026 The Authors. All rights reserved.
// Use of this source code is governed by a license that can
// be found in the LICENSE file.
/*
 * Parts of this file were auto generated. Edit only those parts of
 * the code inside of 'EXISTING_CODE' tags.
 */

package {{toLower .Class}}

// EXISTING_CODE
// EXISTING_CODE

var (
	{{range .Stores}}
	{{toLower .Name}}Store = make(map[string]*store.Store[{{toSingular .Name}}])
	{{toLower .Name}}StoreMu   sync.Mutex
	{{end}}
)

{{range .Stores}}
func (c *{{$class}}Collection) get{{.Name}}Store(payload *types.Payload, facet types.DataFacet) *store.Store[{{toSingular .Name}}] {
	{{toLower .Name}}StoreMu.Lock()
	defer {{toLower .Name}}StoreMu.Unlock()

	// EXISTING_CODE
	// EXISTING_CODE
	
	storeKey := getStoreKey(payload)
	theStore := {{toLower .Name}}Store[storeKey]
	if theStore == nil {
		queryFunc := func(ctx *output.RenderCtx) error {
			// EXISTING_CODE
			// EXISTING_CODE
			return nil
		}

		processFunc := func(item interface{}) *{{toSingular .Name}} {
			if it, ok := item.(*{{toSingular .Name}}); ok {
				// EXISTING_CODE
				// EXISTING_CODE
{{if .NeedsBuckets}}				c.update{{.Name}}Bucket(it)
{{end}}				return it
			}
			return nil
		}

		mappingFunc := func(item *{{toSingular .Name}}) (key string, includeInMap bool) {
			{{- if .GetMapKey }}
			testVal := {{.GetMapKey}}
			return testVal, testVal != ""
			{{- else}}
			return "", false
			{{- end}}
		}

		storeName := c.getStoreName(payload, facet)
		theStore = store.NewStore(storeName, queryFunc, processFunc, mappingFunc)

		// EXISTING_CODE
		// EXISTING_CODE
		
		{{toLower .Name}}Store[storeKey] = theStore
	}

	return theStore
}
{{end}}

func (c *{{$class}}Collection) getStoreName(payload *types.Payload, facet types.DataFacet) string {
	name := ""
	switch facet {
	{{range .Facets}}case {{$class}}{{.Name}}:
		name = "{{toLower $class}}-{{toLower .StoreName}}"
	{{end -}}
	default:
		return ""
	}
	name = fmt.Sprintf("%s-%s-%s", name, payload.ActiveChain, payload.ActiveAddress)
	return name
}

var (
	collections   = make(map[string]*{{.Class}}Collection)
	collectionsMu sync.Mutex
)

func Get{{.Class}}Collection(payload *types.Payload) *{{.Class}}Collection {
	collectionsMu.Lock()
	defer collectionsMu.Unlock()

	pl := *payload
	{{- if $isNames}}
		pl.ActiveAddress = ""
		pl.ActiveChain = ""
	{{end}}
	key := getStoreKey(&pl)
	if collection, exists := collections[key]; exists {
		return collection
	}

	collection := New{{.Class}}Collection(payload)
	collections[key] = collection
	return collection
}

func getStoreKey(payload *types.Payload) string {
	// EXISTING_CODE
	// EXISTING_CODE
	{{- if eq .StoreType "singleton"}}
	_ = payload
	return "singleton"
	{{- else if eq .StoreType "chain-scoped"}}
	return payload.ActiveChain
	{{- else }}
	return fmt.Sprintf("%s_%s", payload.ActiveChain, payload.ActiveAddress)
	{{- end}}
}

// EXISTING_CODE
// EXISTING_CODE
