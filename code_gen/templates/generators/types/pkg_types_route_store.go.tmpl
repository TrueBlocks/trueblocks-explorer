/*
output: pkg/types/[[route]]/store.go
scope: type
*/

{{- $class := .Class -}}
{{- $lower := toLower $class -}}
{{- $isNames := eq .Class "Names" -}}
// Copyright 2016, 2026 The Authors. All rights reserved.
// Use of this source code is governed by a license that can
// be found in the LICENSE file.
/*
 * Parts of this file were auto generated. Edit only those parts of
 * the code inside of 'EXISTING_CODE' tags.
 */

package {{toLower .Class}}

// EXISTING_CODE
// EXISTING_CODE

var (
	{{range .Stores}}
	{{toLower .Name}}Store = make(map[string]*store.Store[{{toSingular .Name}}])
	{{toLower .Name}}StoreMu   sync.Mutex
	{{end}}
)

{{range .Stores}}
{{- $isDyn := eq .Name "AddressList"}}
{{- $storeName := .Name}}
func (c *{{$class}}Collection) get{{.Name}}Store(payload *types.Payload{{if not $isDyn}}, facet types.DataFacet{{end}}) *store.Store[{{toSingular .Name}}] {
	{{toLower .Name}}StoreMu.Lock()
	defer {{toLower .Name}}StoreMu.Unlock()

	// EXISTING_CODE
	// EXISTING_CODE

	storeKey := getStoreKey(payload)
	theStore := {{toLower .Name}}Store[storeKey]
	if theStore == nil {
		queryFunc := func(ctx *output.RenderCtx) error {
			// EXISTING_CODE
			// EXISTING_CODE
			return nil
		}

		processFunc := func(item interface{}) *{{toSingular .Name}} {
			if it, ok := item.(*{{toSingular .Name}}); ok {
				{{- range .Members}}
				{{- $isDB := eq .GoName "DatabaseName" -}}
				{{- if and (not $isDB) (and (hasSuffix .Name "Name") (eq .Type "string"))}}
				{{- $baseName := replace .Name "Name" ""}}
				{{- if $isNames}}
				it.{{.GoName}} = NameAddress(it.{{firstUpper $baseName}})
				{{- else if or (eq $storeName "DalleDress") (eq $storeName "AddressList")}}
				it.{{.GoName}} = names.NameAddressStr(it.{{firstUpper $baseName}})
				{{- else}}
				it.{{.GoName}} = names.NameAddress(it.{{firstUpper $baseName}})
				{{- end}}
				{{- end}}
				{{- end}}
				// EXISTING_CODE
				// EXISTING_CODE
				{{- if .NeedsCalcs}}
				props := &sdk.ModelProps{
					Chain:   payload.ActiveChain,
					Format:  "json",
					Verbose: true,
					ExtraOpts: map[string]any{
						"ether": true,
					},
				}
				if err := it.EnsureCalcs(props, nil); err != nil {
					logging.LogBEError(fmt.Sprintf("Failed to calculate fields during ingestion: %v", err))
				}
				{{- end}}
{{if .NeedsBuckets}}				c.update{{.Name}}Bucket(it)
{{end}}				return it
			}
			return nil
		}

		mappingFunc := func(item *{{toSingular .Name}}) (key string, includeInMap bool) {
			{{- if .GetMapKey }}
			testVal := {{.GetMapKey}}
			return testVal, testVal != ""
			{{- else}}
			return "", false
			{{- end}}
		}

		storeName := c.getStoreName(payload, facet)
		theStore = store.NewStore(storeName, queryFunc, processFunc, mappingFunc)

		// EXISTING_CODE
		// EXISTING_CODE
		
		{{toLower .Name}}Store[storeKey] = theStore
	}

	return theStore
}
{{end}}

func (c *{{$class}}Collection) getStoreName(payload *types.Payload, facet types.DataFacet) string {
	name := ""

	// EXISTING_CODE
	// EXISTING_CODE

	switch facet {
	{{- range .Facets}}
	{{- if not .IsDynamic}}
	case {{$class}}{{.Name}}:
		name = "{{toLower $class}}-{{toLower .StoreName}}"
	{{- end}}
	{{- end}}
	default:
		return ""
	}
	name = fmt.Sprintf("%s-%s-%s", name, payload.ActiveChain, payload.ActiveAddress)
	return name
}

var (
	collections   = make(map[string]*{{.Class}}Collection)
	collectionsMu sync.Mutex
)

func Get{{.Class}}Collection(payload *types.Payload{{if .HasDynamicFacets}}, {{$lower}}Manager *manager.Manager[*{{toSingular $lower}}.{{toSingular .Class}}]{{end}}) *{{.Class}}Collection {
	collectionsMu.Lock()
	defer collectionsMu.Unlock()

	pl := *payload
	{{- if $isNames}}
		pl.ActiveAddress = ""
		pl.ActiveChain = ""
	{{end}}
	key := getStoreKey(&pl)
	if collection, exists := collections[key]; exists {
		return collection
	}

	collection := New{{.Class}}Collection(payload{{if .HasDynamicFacets}}, {{$lower}}Manager{{end}})
	collections[key] = collection
	return collection
}

func getStoreKey(payload *types.Payload) string {
	// EXISTING_CODE
	// EXISTING_CODE
	{{- if eq .StoreType "singleton"}}
	_ = payload
	return "singleton"
	{{- else if eq .StoreType "chain-scoped"}}
	return payload.ActiveChain
	{{- else }}
	return fmt.Sprintf("%s_%s", payload.ActiveChain, payload.ActiveAddress)
	{{- end}}
}

// EXISTING_CODE
// EXISTING_CODE
