/*
output: pkg/types/[[route]]/[[type]].go
scope: type
*/

{{- $class := .Class -}}
{{- $lower := toLower $class -}}
// Copyright 2016, 2026 The Authors. All rights reserved.
// Use of this source code is governed by a license that can
// be found in the LICENSE file.
/*
 * Parts of this file were auto generated. Edit only those parts of
 * the code inside of 'EXISTING_CODE' tags.
 */

package {{$lower}}

import (
	"fmt"
	"sync"
	"time"

	// EXISTING_CODE
	// EXISTING_CODE
	"github.com/TrueBlocks/trueblocks-explorer/pkg/facets"
	"github.com/TrueBlocks/trueblocks-explorer/pkg/logging"
	"github.com/TrueBlocks/trueblocks-explorer/pkg/types"
)

const (
{{range .Facets}}
{{- if not .IsDynamic}}
{{$class}}{{.Name}} types.DataFacet = "{{toLower .Name}}"
{{- end}}
{{- end}}
)

func init() {
	{{- range .Facets}}
	{{- if not .IsDynamic}}
	types.RegisterDataFacet({{$class}}{{.Name}})
	{{- end}}
	{{- end}}
}

type {{$class}}Collection struct {
	{{- range .Facets}}
	{{- $name := toLower .Name -}}
	{{- if not .IsDynamic}}
	{{$name}}Facet *facets.Facet[{{toSingular .StoreName}}]
	{{- else}}
	{{$name}}Facets    map[string]*facets.Facet[{{toSingular .StoreName}}]
	{{$name}}Manager   *manager.Manager[*project.Project]
	{{- end}}
	{{- end}}
	summary         types.Summary
	summaryMutex    sync.RWMutex
}

{{$hasDyn := .HasDynamicFacets -}}
func New{{$class}}Collection(payload *types.Payload{{if $hasDyn}}, {{$lower}}Manager *manager.Manager[*{{toSingular $lower}}.{{toSingular $class}}]{{end}}) *{{$class}}Collection {
	{{- if $hasDyn}}
	c := &{{$class}}Collection{
		{{$lower}}Manager:   {{$lower}}Manager,
		{{$lower}}Facets:    make(map[string]*facets.Facet[AddressList]),
	}
	{{- else}}
	c := &{{$class}}Collection{}
	{{- end}}
	c.ResetSummary()
	c.initializeFacets(payload)
	return c
}

func (c *{{$class}}Collection) initializeFacets(payload *types.Payload) {
	{{- range .Facets}}
	{{- if not .IsDynamic}}
	c.{{toLower .Name}}Facet = facets.NewFacet(
		{{$class}}{{.Name}},
		is{{toSingular .Name}},
		isDup{{.SingleStore}}(),
		c.get{{.StoreName}}Store(payload, {{$class}}{{.Name}}),
		"{{toLower $class}}",
		c,
		{{.UseMapKey}},
	)
	{{- end}}
	{{end -}}
	{{if $hasDyn}}
	if c.{{$lower}}Manager != nil {
		openIDs := c.{{$lower}}Manager.GetOpenIDs()
		for _, id := range openIDs {
			types.RegisterDataFacet(types.DataFacet(id))
		}
	}{{end -}}
}

{{range .Facets}}
func is{{toSingular .Name}}(item *{{toSingular .StoreName}}) bool {
	// EXISTING_CODE
	// EXISTING_CODE
}
{{end}}

{{range .Stores}}
func isDup{{toSingular .Name}}() func(existing []*{{toSingular .Name}}, newItem *{{toSingular .Name}}) bool {
	// EXISTING_CODE
	// EXISTING_CODE
}
{{end}}

func (c *{{$class}}Collection) FetchByFacet(payload *types.Payload) {
	dataFacet := payload.DataFacet
	if !c.NeedsUpdate(payload) {
		return
	}

	go func() {
		switch dataFacet {
		{{- range .Facets}}
		{{- if not .IsDynamic}}
		case {{$class}}{{.Name}}:
			if err := c.{{toLower .Name}}Facet.FetchFacet(); err != nil {
				logging.LogError(fmt.Sprintf("LoadData.%s from store: %%v", dataFacet), err, facets.ErrAlreadyLoading)
			}
		{{- end}}
		{{- end}}
		default:
			{{- if $hasDyn}}
			id := string(dataFacet)
			payload := types.Payload{DataFacet: types.DataFacet(id)}
			c.ensureProjectFacet(&payload)
			if facet, exists := c.{{$lower}}Facets[id]; exists {
				if err := facet.FetchFacet(); err != nil {
					logging.LogError(fmt.Sprintf("LoadData.%s from store: %%v", dataFacet), err, facets.ErrAlreadyLoading)
				}
			}
			{{- else}}
			logging.LogError("LoadData: unexpected dataFacet: %v", fmt.Errorf("invalid dataFacet: %s", dataFacet), nil)
			return
			{{- end}}
		}
	}()
}

func (c *{{$class}}Collection) Reset(payload *types.Payload) {
	switch payload.DataFacet {
	{{- range .Facets}}
	{{- if not .IsDynamic}}
	case {{$class}}{{.Name}}:
		c.{{toLower .Name}}Facet.Reset()
	{{- end}}
	{{- end}}
	default:
		{{- if $hasDyn}}
		c.ensureProjectFacet(payload)
		id := string(payload.DataFacet)
		if facet, exists := c.{{$lower}}Facets[id]; exists {
			facet.Reset()
		}
		{{- end}}
		return
	}
}

func (c *{{$class}}Collection) NeedsUpdate(payload *types.Payload) bool {
	switch payload.DataFacet {
	{{- range .Facets}}
	{{- if not .IsDynamic}}
	case {{$class}}{{.Name}}:
		return c.{{toLower .Name}}Facet.NeedsUpdate()
	{{- end}}
	{{- end}}
	default:
		{{- if $hasDyn}}
		c.ensureProjectFacet(payload)
		id := string(payload.DataFacet)
		if facet, exists := c.{{$lower}}Facets[id]; exists {
			return facet.NeedsUpdate()
		}
		{{- end}}
		return false
	}
}

func (c *{{$class}}Collection) AccumulateItem(item interface{}, summary *types.Summary) {
	// EXISTING_CODE
	// EXISTING_CODE
}

func (c *{{$class}}Collection) GetSummary(payload *types.Payload) types.Summary {
	_ = payload // delint
	c.summaryMutex.RLock()
	defer c.summaryMutex.RUnlock()

	summary := c.summary
	summary.FacetCounts = make(map[types.DataFacet]int)
	for k, v := range c.summary.FacetCounts {
		summary.FacetCounts[k] = v
	}

	if c.summary.CustomData != nil {
		summary.CustomData = make(map[string]interface{})
		for k, v := range c.summary.CustomData {
			summary.CustomData[k] = v
		}
	}

	return summary
}

func (c *{{$class}}Collection) ResetSummary() {
	c.summaryMutex.Lock()
	defer c.summaryMutex.Unlock()
	c.summary = types.Summary{
		TotalCount:  0,
		FacetCounts: make(map[types.DataFacet]int),
		CustomData:  make(map[string]interface{}),
		LastUpdated: time.Now().Unix(),
	}
}

func (c *{{$class}}Collection) ExportData(payload *types.Payload) (string, error) {
	switch payload.DataFacet {
	{{- range .Facets}}
	{{- if not .IsDynamic}}
	case {{$class}}{{.Name}}:
		return c.{{toLower .Name}}Facet.ExportData(payload, string({{$class}}{{.Name}}))
	{{- end}}
	{{- end}}
	default:
		{{- if $hasDyn}}
		// TODO: Export dynamic facet data
		{{- end}}
		return "", fmt.Errorf("[ExportData] unsupported {{$lower}} facet: %s", payload.DataFacet)
	}
}

func (c *{{$class}}Collection) ChangeVisibility(payload *types.Payload) error {
	// EXISTING_CODE
	// EXISTING_CODE

	{{- if $hasDyn}}
	id := string(payload.DataFacet)
	if c.{{$lower}}Manager == nil {
		return fmt.Errorf("item manager not available")
	}

	if err := c.{{$lower}}Manager.Close(id); err != nil {
		return fmt.Errorf("failed to close item %s: %w", id, err)
	}

	delete(c.{{$lower}}Facets, id)
	{{- end}}
	return nil
}

// EXISTING_CODE
// EXISTING_CODE
